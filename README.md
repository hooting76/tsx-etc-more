# 11월 21일   
## redux 기초 학습   
 1. 리액트를 다루다 보니 상태관리에 대해 욕심이 생겨서 관련하여 패키지가 있는지 찾아보다 redux라는 것을 알게 됐다.   

 2. 리액트 프레임워크나 언어별로 시작하는 방법이며 세팅법 등등 가지각색이어서 좀 해매었다. (별도로 로컬에서 nextjs + typescript 기반의 라우터 사용 세팅으로 되어있는 내용을 여기저기 겨우 찾다가 결국엔 전혀 모르겠는 부분은 ai에게 물어보게 됐다.)   

 3. 근데 이것저것 자료를 찾아보니 결국엔 직전 프로젝트에서 contextAPI 와 useReducer를 활용해서 만든 커스텀 훅과 구조가 거의 일치했었다... redux를 몰랐던 상태에서 redux를 자체 제작한 것이었다...      
  - 사실 직전 프로젝트에서 커스텀 훅을 만들기 직전에 잠시 동안 "상태관리 해주는 패키지가 따로 있지 않을까...?" 라는 생각이 스쳐 지나갔지만... 뭐 직접 만들어본것도 나쁜 경험은 아니였겠지.   

 4. 다만 차이점으로는   
  - redux devtool로 모든 액션과 상태 변화에 대해 시각화 가능   
  - 액션 히스토리 추적 기능   
  - 이전 상태로 되돌리기   
  - 코드라인 감소 효과
  등의 차이가 있다.   

  * + 내껀 히스토리 추적이 불가능 하다.   

## CS 학습   
 1. 스레드(thread) + 프로세스(Process)   
  - 프로세스를 구성하는 실행 흐름의 단위   
  - ex) 프로세스: 하나의 집 / 자원: 집 내의 전기, 수도, 공구 등등 / 스레드: 집에 거주하는 가족 구성원   
  - 집 안에서 각 구성원은 집 안의 자원을 각자가 활용하여 각자가 독립적인 일들을 처리한다.   
  - 즉, 프로세스 라는 범위 안의 자원을 함께 사용하는(자원 공유) 작업 단위가 스레드 가 된다.   
  - 하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.   

  * 구성요소: '스레드ID, 프로그램 카운터를 비롯한 레지스터 값, 스택' 등 의 **실행에 필요한 최소한의 정보**   

  ```
    자원 공유로 발생하는 문제점(Feat. 멀티스레드 프로그래밍)   
    1. 동기화 문제 (Synchronization Issues)   
     - 여러 스레드가 동일한 자원(데이터, 메모리)에 동시에 접근시 발생하는 문제   
     - ex) 욕실이 하나인 집에서 새면을 하고자 하는 2명 이상의 구성원   

     * 경쟁 상태(Race Condition)
      - 2개 이상의 스레드가 동시에 같은 데이터를 변경하려할때 발생   
      - 실행 순서에 따라 결과가 완전히 달라질 수 있어 예측이 불가   
    
     * 교착 상태(Deadlock)   
      - 2개 이상의 스레드가 서로가 가진 자원을 기다리며 무한정 대기하는 상태   


    위 문제점들을 해결할 방법   
    1. 동기화 기법 (Synchronization Techniques)   
     * 임계 구역 (Critical Section): 오직 하나의 스레드만 들어갈 수 있도록 보호해야 하는 코드 영역   
     * 뮤텍스 (Mutex) / 세마포어(Semaphore): 임계 구역에 하나의 스레드만 접근하도록 잠그는(lock) 장치   

     * 뮤텍스, 세마포의 중요한 차이점: 소유권(Ownership) 개념   
      - 뮤텍스: 오직 하나의 스레드만 접근 허용. 해당 스레드에게만 소유권이 있다.   
      - 세마포어: 한정된 자원에 대해서만 관리함으로 여러 스레드의 접근이 허용. 이에 따라 해당되는 다른 스레드도 상태 해제가 가능함으로 소유권이 따로 없다.   
    
    ** 참고   
     - 동시성 (Concurrency): '싱글코어에서도' 여러 작업을 아주 빠르게 번갈아가며 처리해서 동시에 실행되는 것 처럼 보이게 하는 것   
     - 병렬성 (Parallelism): '멀티코어에서' 실제로 여러 작업을 동시에 물리적으로 처리하는 것   


    관련 알고리즘(패턴)   
     1. 뮤텍스 - 배타적 접근(Exclusive Acess) => 임계 구역 보호 보장

      * 임계 구역 문제 해결 (Critical Section Problem)   
       - 뮤텍스의 가장 기본이며 핵심적인 사용법   
       - 하나의 스레드만 해당 해당하는 코드를 실행하도록 보장   
      
      * 모니터(Monitor)   
       - 뮤텍스 상위의 고수준 패턴   
       - 공유 데이터와 이 데이터에 접근하는 함수를 하나로 묶음   
       - 이 묶음 전체에 대해 뮤텍스를 적용하는 방법   
       - 개발자가 직접 잠금/헤제를 신경쓰지 않아도 모니터에 속한 함수를 호출하면 자동으로 한 스레드만 실행되도록 보장   


     2. 세마포어 - 카운터(Counter): 자원의 갯수 관리 || 특정 순서에 따라 스레드 실행의 경우에 사용  => 잘못된 사용으로 인한 임계구역 보호x => 경쟁 상태로 빠질 수 있는 위험성이 있다

      * 생산자-소비자 문제 (Producer-Consumer Problem)   
       - 가장 고전적인 세마포어 활용 예시   
        *) 생산자 스레드: 데이터를 생성하여 공유 버퍼(저장 공간)에 input   
        *) 소비자 스레드: 공유 버퍼(저장 공간)에 저장된 데이터를 가져와서 사용 => 이때, 세마포를 활용하여 '버퍼에 남은 공간의 수' 와 '버퍼에 채워진 데이터 수' 를 세어서 생상자와 소비자가 올바르게 동작하도록 동기화   

      * 읽기-쓰기 문제 (Readers-Writers Problem)   
       - 읽기: 여러 스레드가 읽기 가능 / 쓰기: 오직 하나의 스레드만 쓰기에 접근해야 하는 상황   
       - 읽기 스레드는 여러 개가 동시 접근 가능   
       - 쓰기 스레드는 독점적으로 접근해야만 한다. 이 동안, 다른 모든 읽기/쓰기 스레드들은 대기 상태   

      * 식사하는 철학자 문제 (Dining Philosophers Problem)   
       - 교착 상태를 설명하기 위한 아주 유명한 문제   
       - 이 문제에 대해 순서대로 집기, 한 명만 덜 집게 하기 등의 해결 알고리즘이 존재함   

    + 해당 알고리즘들은 실제 시스템에서 자주 발생하는 상황들에 대한 모델링   
  ```   

 2. CPU 스케줄링   
  - OS가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것   

  * 프로세스 우선순위   
   -예시: I/O 작업이 많은 프로세스(I/O 집중 프로세스) > CPU작업이 많은 프로세스(CPU 집중 프로세스)   

   1) 스케줄링 큐   
    * {대기 상태(대기 큐)} ===입출력 완료(인터럽트)===> {준비상태(준비 큐)} ====디스패치====> {실행 상태} 
    * {실행상태}: ====실행시간 완료(타이어 인터럽트)====> {준비상태(준비 큐)} // ====입출력장치 요청====> {대기 상태(대기 큐)} // =======> {종료 상태}
    * 스케줄링에서의 큐는 반드시 선입선출(FIFO) 방식일 필요는 없다.   
    * 준비 큐: CPU 사용을 위한 대기하는 큐   
    * 대기 큐: 같은 장치를 요구하는 프로세스들은 같은 큐에서 대기   


   2) 선점형 스케줄링 / 비선점형 스케줄링   
    * 선점형 스케줄링(Preemptive Scheduling): 현재 CPU를 사용중인 프로세스로부터 CPU자원을 빼앗아 다른 프로세스에 할당 (테토 스케줄링)   
    * 비선점형 스케줄링(Non-Preemptive Scheduling): 현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기 (에겐 스케줄링)   

    * 각 특징   
     - 선점형: 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분 / 그만큼 문맥 교환 과정에서 오버헤드가 발생 가능   
     - 비선점형: 선점형 스케줄링보다 문맥 교환에서 발생하는 오버헤드가 작음 / 모든 프로세스가 골고루 지원을 이용하기 어려움   


 3. 스케줄링 알고리즘 몇가지   

  * 선입 선처리 스케줄링 = FCFS(First Come First Served) 스케줄링   
   1) 비선점 스케줄링   
   2) 단순히 준비 큐에 삽입된 순서대로 처리
   3) 먼저 CPU를 요청한 프로세스부터 순차적으로 CPU 할당   
   4) 단점: 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 => 호위 효과   


  * 최단 작업 우선 스케줄링 = SJF(Shortest Job First) 스케줄링   
   1) CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
   2) CPU 사용 시간이 가장 짫은 프로세스부터 처리   


  * 라운드 로빈 스케줄링 = RR(Round Robin) 스케줄링   
   1) 선점형 스케줄링: 정해진 타임 슬라이스 만큼의 시간 동안 돌아가며 CPU를 사용   
   2) 선입 선처리 스케줄링(FCFS) + 타임 슬라이스(time slice) 구조   
   3) 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간 / 각 프로세스 별 CPU 최대 대여 시간   
    - 큐에 들어온 프로세스들은 순서대로 정해진 시간 만큼 CPU를 사용   
    - 사용 시간이 오버되어도 프로세스가 끝나지 않았다면 다시 큐의 맨 뒤에 추가 (문맥 교환)   
   => 이와 같은 특징들로 인해 타임 슬라이스의 크기가 중요하다.   


  * 최소 잔여 시간 우선 스케줄링 = SRT(Shortest Remaining Time) 스케줄링   
   1) 최단 작업 우선 스케줄링(SJF) + 라운드 로빈 스케줄링(RR)   
    - 작업 시간이 짧은 프로세스부터 처리 + 정해진 타임슬라이스 만큼 돌아가며 사용 하는 특징이 혼합   
   2) '정해진 시간(타임 슬라이스)만큼 CPU를 사용'하되, 다음 CPU를 사용할 프로세스로는 '남은 작업 시간이 가장 적은 프로세스' 선택   


  * 우선순위 스케줄링   
   1) 프로세스 마다 우선순위 부여 => 우선순위가 높은 프로세스부터 실행   
   2) 같은 우선순위의 프로세스들의 경우 => 선입 선처리 실행   
   3) 우선순위 스케줄링 개념에 SJF, SRT 스케줄링을 포함한다.   
   4) 문제점: 기아(Starvation) 현상 발생
    - 우선순위가 높은 프로세스만 계속 실행   
    - 우선순위가 낮은 프로세스는 계속 실행이 연기(준비 큐에 먼저 들어 왔음에도)   
   5) 기아 현상 방지 기법: 에이징(aging)   
    - 오랫동안 대시한 프로세스의 우선순위를 점차 높이는 방식(같은계급, 짬 차이)   


  * 다단계 큐 스케줄링 = Multilevel queue 스케줄링   
   1) 우선순위 스케줄링의 발전 형태   
   2) 우선순위 별로 준비 큐를 여러 개 사용하는 스케줄링 방식 / 기존 프로세스 마다의 우선순위 부여가 아닌 큐 단위의 우선순위 부여 인듯   
   3) 우선순위가 가장 높은 큐 순서대로 프로세스를 처리 / 가장 높은 우선순위 큐가 없다면 차등으로 프로세스 처리   

  
  * 다단계 피드백 큐 스케줄링 = Multilevel feedback queue 스케줄링   
   1) 다단계 큐 스케줄링의 발전형태   
   2) 큐 간의 이동이 가능한 다단계 큐 스케줄링   
   3) 기본적으로 큐 간의 이동이 불가 / 큐 자체가 프로세스 하나의 단위처럼 취급   
    - 이로 인해 기아 현상 발생 가능   
   => 즉, 우선순위 방식을 큐 단위로 적용한 CPU 스케줄링 방식이다.   


 4. 프로세스 동기화
  * 동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받는다   
    => 프로세스들의 동기화를 고려해야 한다. = 이 과정에서 자원의 일관성을 보장해야 한다.   

  * 즉, 프로세스 동기화는 자원의 일관성 보장을 위해 존재한다. 
  * 의미
    1) 공동의 목적을 위해 동시에 수행되는 프로세스   
    2) 올바른 수행을 위한 프로세스   
      **즉, 프로세스 동기화는 프로세스들의 수행시기를 맞추는 것**   
      **실행의 문맥을 갖는 모든 대상이 동기화 대상이다. 즉, 스레드도 동기화 대상이다.**
  
  * 실행 순서 제어를 위한 동기화(실행의 순서): 프로세스를 올바른 순서대로 실행하기 / 읽기-쓰기 문제    
  * 상호 배제를 위한 동기화(Bank Account Problem): 동시 접근하면 안되는 자원 **(공유 불가 자원)** 에 하나의 프로세스만 접근하게 하기   

  * 공유 자원: 여러 프로세스 || 스레드가 공유하는 자원   
    - 전역 변수, 파일, 입출력장치, 보조기억장치 등등   
  
  * 임계 구역: 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
    - 앞선 공유 불가 자원 등등   
    - 해당 구역에 진입하기 위해서는 진입하는 프로세스 이외에는 대기해야 한다.   
    - **임계 구역에 동시 접근시, 자원의 일관성이 깨질 수 있다. 이를 경쟁 상태(race condition) 라고 한다.**

   * OS가 이와 같은 임계구역 문제를 해결하는 3가지 원칙   
    1) 상호 배제: 설명 생략   
    2) 진행: 임계 구역에 어떤 프로세스도 없다면 진입하고자 하는 프로세스가 진입이 가능해야 한다.   
    3) 유한 대기: 무한정의 대기 상태가 아닌 언젠가는 임계구역에 진입이 되어야 한다.   


# 11월 20일   
## Next.js + Typescript 를 활용한 예시 연습   
 1. 개인 노트북에 Next.js 를 설치하고 기초적인 컴포넌트 호출 방식과 구조, 타입 지정 등을 실습해봄.   

 2. 사이드 프로젝트 사전 조사
  - 몇년전에 장고프레임워크(django) 로 개발했던 프로젝트를 리펙토링 하는 개념으로 당시 같이 프로젝트를 진행했던 지인과 해당 프로젝트를 리마스터링 해보기로 했다.   
  - 그에 따라 자주 쓰일듯한 타입이나 DB 테이블 등을 유추하면서 앞서 1번에 실습 대상으로 진행해 보았다.   
  - 아직 CHARSET이나 통신 방식, 인증 방식 등 정해진바가 없어서 우선은 시맨틱태그 별로 컴포넌트 단위로 나누는 실습을 진행해봤고, 이후 스펙시트가 정해지는데로 맞춰서 구축해 나갈 계획. 다음 미팅 날짜는 26일이다.   

 3. 기타   
  - 타입스크립트가 개발하는 동안에는 힘들게 하는건 분명하지만, 이 상황에 익숙해지면 이만큼 정교한 언어도 별로 없을것 같다. 진짜 자바를 많이 닮은 모습이 보인다.   
  - 제대로 다룰줄 안다면 강력한 이점인건 분명하다. 당분간 Next.js와 타입스크립트에 익숙해져야겠다.   

# 11월 19일   
## CS 학습   
 1. 컴퓨터 구조를 왜 알아야 하는가   
  1) 컴퓨터의 근간을 알아야 하기 때문 -> 문제 해결 능력 + 성능, 용량, 비용 등의 이점
  2) 문제 해결 능력   
    - 내가 입력한 소스코드에 대한 컴퓨터 내의 동작 원리등의 분석을 통해 문제 해결 능력을 배양 / 미지의 대상 => 분석의 대상   
  3) 성능, 용량, 비용   
    - 개발에서 가장 중요한 요소중 하나.   
    - 컴퓨터 구조 => 컴퓨터가 이해하는 정보 / 컴퓨터의 4가지 핵심 하드웨어   
    - 컴퓨터가 이해하는 정보 => 데이터 / 명령어   
    - 데이터: 문자, 이미지, 동영상, 문서 등과 같은 정적 정보 / 컴퓨터와 주고받는(혹은 저장된) 정보를 데이터라 부르기도 함.   
    - 명령어: 컴퓨터를 실질적으로 움직이는 정보 / 명령어의 입장에서는 데이터는 일종의 제료 역할(그래서 정보 이전의 형태를 데이터, 가공되어 나타내어지는 것이 정보 라 표기하는 이유)   
    - 기본적으로 소스 코드 -> 컴파일링 -> 명령어 로 변환 과정을 거쳐 컴퓨터가 동작한다.   
    <hr/>
    - 컴퓨터의 4가지 핵심 하드웨어: CPU / 보조기억장치(Drive) / 주기억장치(RAM) / 입출력장치(IO Device)   
    - RAM: '현재 실행되는' 프로그램의 명령어와 데이터를 저장한다. => 즉, 프로그램 실행을 위해선 메모리에 적재해야 한다. / 휘발생 메모리   
    - CPU 내부 구성: ALU: 계산기 / 레지스터: CPU 내의 작은 임시저장장치 / 제어장치: 제어 신호(전기 신호)를 보내고 명령어를 해석하는 장치   
    - 동작 예시: 메모리 접근하여 특정 위치의 데이터를 가져옴 -> 메모리 데이터 읽기(제어장치) -> 제어 신호 보내기(특정 메모리 주소지로 제어장치에서 제어 신호 발송)   
    - 이어서 특정 메모리 주소지의 데이터를 받아와서 레지스터에 적재 -> ALU 에 해당 데이터에 대한 연산 처리 -> ALU가 레지스터에 연산 이후 데이터를 적재   
    - 이후 제어 신호에 따라 메모리에 저장하든지, 뭘 하든지 한다.
    - 이 같은 부품들을 하나로 묶는 개념이 마더보드(HW) 혹은 시스템 버스(일종의 통로) 라고 한다.(나무 기둥 느낌)   
    <hr/>
  4) 시스템 버스 내부 구성   
    - 주소 버스: 메모리 주소를 주고 받는 통로   
    - 데이터 버스: 명령어와 데이터를 주고받는 통로   
    - 제어 버스: 제어 신호를 주고 받는 통로   
    <hr/>   

 2. 운영체제 (OS)   
  1) 자원   
    - 프로그램이 실행되기 위해 마땅히 필요한 요소   
    - '실행중인 프로그램'(process)을 관리하는 프로그램   

  2) OS 또한 프로그램이기에 메모리에 저장되어 있다.   
    - 커널영역(운영체제) / 사용자 영역(응용 프로그램)   
    - 즉, 사용자 영역의 응용 프로그램들을 관리하면서 커널영역에서 자원(ex: 메모리 주소)을 관리하는 역할을 수행한다.   
    - 혹여나 물리적인 메모리 크기 보다 큰 응용 프로그램을 적재해야 할때도 운영체제가 '페이징'과 '스와핑' 방식으로 실행가능하도록 해준다.   

  3) 페이징   
    - 프로세스의 물리 메모리를 비연속적으로 할당할 수 있도록 해주는 해주는 운영체제의 메모리 관리 기법.   
    - 페이지(Page): '논리메모리(가상 메모리)'를 동일한 크기로 나눈 블록   
    - 프레임(Frame): '물리 메모리'를 동일한 크기로 나눈 블록   
    - 주로 4kb 혹은, 8kb 단위로 사용   
    - 특징   
      1) 외부 단편화   
        - 고정 크기 단위 할당으로 외부 단편화 발생 x   
        - 효율적인 메모리 공간 활용   

      2) 페이지 테이블(Page Table)   
        - 논리 주소를 물리 주소로 변환하는 맵핑 테이블   
        - 각각의 프로세스마다 독립적인 페이지 테이블 소유 (바로 위의 사유로 인해)   
        - 페이지 번호와 프레임 번호를 매핑   

      3) 주소 변환 과정
        - 페이지 번호로 페이지 테이블을 조회   
        - 해당 프레임 번호 + 오프셋 = 물리주소 로 유추하여 맵핑   
    
    - 장점   
      1) 외부 단편화 해결   
      2) 물리 메모리를 비연속적 할당 가능   
      3) 메모리 보호와 공유가 용이함   

    - 단점   
      1) 내부 단편화 발생 가능 (페이지 내부의 남는 공간에 대해)   
      2) 페이지 테이블을 위한 추가 메모리 필요(어찌보면 메타 데이터이니...)   
      3) 주소 변환 오버해드   
    
    - 요약: 페이징은 현대 운영체제에서 가상 메모리 구현의 기반이되는 기술이다. / 패킷 처럼 조각내어 프로세싱하는 방식(?)   
  
  4) 스와핑   
    - 메모리가 부족할때, 프로세스 전체를 주기억장치(RAM)와 보조기억장치(Drive) 사이에서 이동시키는 메모리 관리 기법.
    - Swap-out: 메모리에서 드라이브로 프로세스를 내보냄 / Swap-in: 드라이브에서 메모리로 프로세스를 불러옴   
    - 다른 프로세스가 실행중 이거나 대기 상태일때, 해당 프로세스를 드라이브의 스왑영역(Swap Space)으로 이동시켜 메모리 공간을 확보   
    - (사용안하는 프로세스를 드라이브에 저장했다가 사용할때만 메모리에 적재하는 방식인듯)   

    - 스와핑 과정
      1) 메모리 부족 감지   
      2) 실핼중이지 않는 프로세스를 선택   
      3) 선택된 프로세스를 통째로 드라이브로 이동 / (Swap - Out)   
      4) 메모리 확보: 비워진 공간에 새 프로세스 적재   
      5) 이후, 필요할 때 디스크에서 다시 메모리로 호출 / (Swap - In)   
    
    - 특징   
      1) 전체 프로세스 단위로의 이동   
        - 프로세스의 모든 데이터를 한꺼번에 이동 / (코드, 데이터, 스택 등)   
        - 페이징의 페이지 단위 이동과는 다름(페이징은 프로세스를 쪼개서 이동하는 방식)   
      
      2) 컨텍스트 스위칭과의 관계   
        - 프로세스 전환 시 마다 스와핑 발생 가능성
        - CPU 스케줄러가 스왑된 프로세스를 선택하면 Swap-In 작업 필요 / CPU 부하량 증가   
      
      3) 스왑 공간(Swap Space)   
        - 디스크의 일부 영역을 스왑 전용으로 할당되어짐   
        - 일반 파일 시스템보다 빠른 접근을 위해 별도로 관리   
        
    - 장점   
      1) 물리 메모리보다 더 많은 프로세스 실행 가능   
      2) 멀티프로그래밍의 정도(degree) 향상   
      3) 메모리 활용도 증대   

    - 단점   
      1) 디스크 i/o가 매우 느림으로 인해 주요 성능 저하 요인으로 지목됨   
      2) 스와핑 오버헤드가 큼   
      3) 프로세스 전체를 이동시킴으로 시간이 오래 걸림   

    - 현대적 변형 / 페이지 스와핑 방식   
      - 전통적인 스와핑 방식보다 페이지 단위 스와핑을 주로 사용   
      1) 프로세스 전체가 아닌 개별 페이지에 대해서만 swap이 이루어짐   
      2) 가상 메모리와 결합하여 더 효율적인 동작   
      3) 페이지 폴트 발생 시, 필요한 페이지만 호출   

    - 요약: 스와핑은 메모리 부족 문제를 해결하는 고전적 기법이지만, 성능 오버헤드가 커서 페이징 방식과 결합한 방식을 현대 시스템에서 사용한다.    

    * 오버헤드(overhead): 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리(자원을 말하는 듯)등을 말한다.   


  5) CPU 스케줄링: 여러 프로그램들이 동시에 CPU를 필요로 할 때, 어느 프로세스 부터 처리할지 부터 얼마나 실행할지에 대한 CPU 리소스 할당에 대한 OS의 관리를 말함.  

  6) 시스템 호출(System Call): 무차별적 자원 접근을 막기위해 OS가 하드웨어와 사용자영역 사이에 위치하여 자원접근에 대한 대리자의 역할을 수행. / (중간자 역할 / JAVA의 Interface의 역할인듯)   

  7) *운영체제는 사용자를 위한 프로그램이 아니다. => 프로그램을 위한 프로그램이다. => 그래서 프로그램을만드는 개발자는 운영체제를 알아야 한다.   
    - ex) 리턴되는 오류에 대해 좀 더 근원적인 분석과 접근이 가능해지면서 문제 해결 능력이 상승한다.   
  
  

# 11월 17일
 1. Wine 설치
 -- Wine is not emulator --
  - wine은 Linux와 같은 Unix 계열 운영체제에서 윈도우즈 프로그램을 실행할 수 있도록 해주는 호환성 계층(compatibility layer)다.
  - 즉, 윈도우에서의 동작을 재구성해서 리눅스에서 직접 실행될 수 있도록 하는 방식.(일종의 컨버팅?)   

  ```bash
    sudo apt update # wine 설치 과정
    sudo apt install wine
  ```   

  - 설치 이후, 별도의 기본적인 설정을 할 수 있다.(winecfg)
  (윈도우즈 환경 설정 + 필요한 라이브러리 드라이버 설치 가능)   


  2. wine을 활용하여 카카오톡 설치   
   1) 우선 윈도우 버전의 카카오톡 설치파일을 다운로드하여 준비한다.(exe 파일...;;)   
   2) 이후, 터미널에 다음 명령어를 입력해주고 실행.   
   ```bash
    LANG="ko_KR.UTF-8" wine kakaoTalk_Setup.exe
   ```   
   3) 이후 과정은 윈도우 설치과정과 동일하다.   
    - 다만, 속도가 좀 느리다...   
  

  3. 타입스크립트로 카페 키오스크 페이지 코드 짜보기
   - 타입을 생성하고 import하여 타입을 준수하여 짜보는거 해보는중...   
   
  
  4. GIMP 설치   
   - 우분투 환경에서는 포토샵 프로그램으로 GIMP 가 그역할을 하고있다.   
   ```bash
    sudo apt update
    sudo apt install gimp
   ```   

   5. Remmina 설치
    - 집에 있는 미니PC 원격연결이 필요할수도 있어서 원격연결 방법을 찾던중 해당 프로그램을 찾게 되었다.
    ``` bash   
      # Remmina 수동 설치하기
      $ sudo snap install remmina
    ```   

    - 이후 어떤 경고문이 뜰텐데, snap 으로 설치할 경우에 대한 보안상의 이유로 명시해준다.   
    - 따라서, 수동으로 제한을 풀어주는작업을 진행했다.   

    ``` bash
      # Remmina permission settings
      $ sudo snap connect remmina:audio-record :audio-record
      $ sudo snap connect remmina:avahi-observe :avahi-observe
      $ sudo snap connect remmina:cups-control :cups-control
      $ sudo snap connect remmina:mount-observe :mount-observe
      $ sudo snap connect remmina:password-manager-service :password-manager-service
    ```   

    - 이후 프로그램 실행 후, 프로토콜값을 RDP로 바꿔준 이후, ip주소와 유저정보를 입력하여 원격연결에 성공했다.   
    



# 11월 14일
 1. 가지고있던 노트북 하나를 다 밀고 우분투를 설치했다...
  - refus 로 부팅용 usb(8기가 이상) 하나 포맷해주고 우분투 iso 파일로 구워서 노트북에 설치
  - 스펙사항:
    - Ubuntu 24.04.3 LTS
    - Acer Aspire E5-576
    - Intel® Core™ i5-8250U × 8
    - memory : 16.0 GiB

  - 설치 및 세팅
    1) Vim
    ``` bash
      $ sudo apt-get update
      $ sudo apt-get install vim
    ```   

    2) Git
    ```bash
      $ sudo apt update
      $ sudo add-apt-repository ppa:git-core/ppa
      $ sudo apt update
      $ sudo install git

      # git이 정상 설치됐는지 확인
      $ git version

      # 유저명과 이메일 주소 설정
      $ git config --global user.name name
      $ git config --global user.email name@email.com

      # 유저명과 이메일 주소 확인
      $ git config user.name
      $ git config user.email
    ```
  
    3) 우분투 vscode에서 한글 입력 안됐던 문제... 
    - https://gist.github.com/philoskim/a79440bd51ae40f04a4d7cafa472caf1
    - 결론: snap(앱센터) 으로 설치하지 말고 전통적인 방식을 고수하자...   

    4) 이외 여럿 설치 항목도 있지만 충분히 구글링 하면서 해결완료   

    <hr/>

 2. 리액트 타입스크립트 학습시작
  - 깃허브 : https://github.com/hooting76/tsx-etc-more   
  - 내용   
    1) 타입스크립트는 input/output 각각 타입을 분명하게 명시해야 한다.   
    2) 이러한 타입중에 객체형태의 타입은 따로 ts파일로 저장해서 사용하며, model 이란 폴더명으로 관리한다.
    3) type 과 interface 의 타입이 각각 존재하며, 차이는 다음과 같다.   


-------------------------------------------------
| 구분 | `interface` | `type` |
|------|-------------|--------|
| **선언 병합** | ✅ 가능 (같은 이름으로 여러 번 선언 시 자동 병합) | ❌ 불가능 (중복 선언 시 에러) |
| **확장 방식** | `extends` 키워드 사용 | `&` (인터섹션) 사용 |
| **Union 타입** | ❌ 불가능 | ✅ 가능 (`string \| number`) |
| **Tuple 타입** | ❌ 불가능 | ✅ 가능 (`[string, number]`) |
| **Primitive 별칭** | ❌ 불가능 | ✅ 가능 (`type ID = string`) |
| **Mapped Types** | ❌ 불가능 | ✅ 가능 |
| **객체 타입 정의** | ✅ 가능 | ✅ 가능 |
| **성능** | 약간 더 빠름 (캐싱 최적화) | 약간 느림 |   
--------------------------------------------------   

## 정리

--------------------------
| 상황 | 추천 |
|------|------|
| **공개 API/라이브러리** | `interface` (사용자가 확장 가능) |
| **React Props/State** | `interface` (명확한 에러 메시지) |
| **일반 객체 타입** | `interface` |
| **Union/Intersection** | `type` |
| **Tuple 타입** | `type` |
| **Utility/Helper 타입** | `type` |
| **복잡한 타입 조합** | `type` |
---------------------------

## 예시 : 확장 (Extension)   
```typescript
// interface
interface Animal {
  name: string;
}
interface Dog extends Animal {
  bark(): void;
}

// type
type Animal = {
  name: string;
}
type Dog = Animal & {
  bark(): void;
}
```
