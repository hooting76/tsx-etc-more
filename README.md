# 11월 20일   
## Next.js + Typescript 를 활용한 예시 연습   
 1. 개인 노트북에 Next.js 를 설치하고 기초적인 컴포넌트 호출 방식과 구조, 타입 지정 등을 실습해봄.   

 2. 사이드 프로젝트 사전 조사
  - 몇년전에 장고프레임워크(django) 로 개발했던 프로젝트를 리펙토링 하는 개념으로 당시 같이 프로젝트를 진행했던 지인과 해당 프로젝트를 리마스터링 해보기로 했다.   
  - 그에 따라 자주 쓰일듯한 타입이나 DB 테이블 등을 유추하면서 앞서 1번에 실습 대상으로 진행해 보았다.   
  - 아직 CHARSET이나 통신 방식, 인증 방식 등 정해진바가 없어서 우선은 시맨틱태그 별로 컴포넌트 단위로 나누는 실습을 진행해봤고, 이후 스펙시트가 정해지는데로 맞춰서 구축해 나갈 계획. 다음 미팅 날짜는 26일이다.   

 3. 기타   
  - 타입스크립트가 개발하는 동안에는 힘들게 하는건 분명하지만, 이 상황에 익숙해지면 이만큼 정교한 언어도 별로 없을것 같다. 진짜 자바를 많이 닮은 모습이 보인다.   
  - 제대로 다룰줄 안다면 강력한 이점인건 분명하다. 당분간 Next.js와 타입스크립트에 익숙해져야겠다.   

# 11월 19일   
## CS 학습   
 1. 컴퓨터 구조를 왜 알아야 하는가   
  1) 컴퓨터의 근간을 알아야 하기 때문 -> 문제 해결 능력 + 성능, 용량, 비용 등의 이점
  2) 문제 해결 능력   
    - 내가 입력한 소스코드에 대한 컴퓨터 내의 동작 원리등의 분석을 통해 문제 해결 능력을 배양 / 미지의 대상 => 분석의 대상   
  3) 성능, 용량, 비용   
    - 개발에서 가장 중요한 요소중 하나.   
    - 컴퓨터 구조 => 컴퓨터가 이해하는 정보 / 컴퓨터의 4가지 핵심 하드웨어   
    - 컴퓨터가 이해하는 정보 => 데이터 / 명령어   
    - 데이터: 문자, 이미지, 동영상, 문서 등과 같은 정적 정보 / 컴퓨터와 주고받는(혹은 저장된) 정보를 데이터라 부르기도 함.   
    - 명령어: 컴퓨터를 실질적으로 움직이는 정보 / 명령어의 입장에서는 데이터는 일종의 제료 역할(그래서 정보 이전의 형태를 데이터, 가공되어 나타내어지는 것이 정보 라 표기하는 이유)   
    - 기본적으로 소스 코드 -> 컴파일링 -> 명령어 로 변환 과정을 거쳐 컴퓨터가 동작한다.   
    <hr/>
    - 컴퓨터의 4가지 핵심 하드웨어: CPU / 보조기억장치(Drive) / 주기억장치(RAM) / 입출력장치(IO Device)   
    - RAM: '현재 실행되는' 프로그램의 명령어와 데이터를 저장한다. => 즉, 프로그램 실행을 위해선 메모리에 적재해야 한다. / 휘발생 메모리   
    - CPU 내부 구성: ALU: 계산기 / 레지스터: CPU 내의 작은 임시저장장치 / 제어장치: 제어 신호(전기 신호)를 보내고 명령어를 해석하는 장치   
    - 동작 예시: 메모리 접근하여 특정 위치의 데이터를 가져옴 -> 메모리 데이터 읽기(제어장치) -> 제어 신호 보내기(특정 메모리 주소지로 제어장치에서 제어 신호 발송)   
    - 이어서 특정 메모리 주소지의 데이터를 받아와서 레지스터에 적재 -> ALU 에 해당 데이터에 대한 연산 처리 -> ALU가 레지스터에 연산 이후 데이터를 적재   
    - 이후 제어 신호에 따라 메모리에 저장하든지, 뭘 하든지 한다.
    - 이 같은 부품들을 하나로 묶는 개념이 마더보드(HW) 혹은 시스템 버스(일종의 통로) 라고 한다.(나무 기둥 느낌)   
    <hr/>
  4) 시스템 버스 내부 구성   
    - 주소 버스: 메모리 주소를 주고 받는 통로   
    - 데이터 버스: 명령어와 데이터를 주고받는 통로   
    - 제어 버스: 제어 신호를 주고 받는 통로   
    <hr/>   

 2. 운영체제 (OS)   
  1) 자원   
    - 프로그램이 실행되기 위해 마땅히 필요한 요소   
    - '실행중인 프로그램'(process)을 관리하는 프로그램   

  2) OS 또한 프로그램이기에 메모리에 저장되어 있다.   
    - 커널영역(운영체제) / 사용자 영역(응용 프로그램)   
    - 즉, 사용자 영역의 응용 프로그램들을 관리하면서 커널영역에서 자원(ex: 메모리 주소)을 관리하는 역할을 수행한다.   
    - 혹여나 물리적인 메모리 크기 보다 큰 응용 프로그램을 적재해야 할때도 운영체제가 '페이징'과 '스와핑' 방식으로 실행가능하도록 해준다.   

  3) 페이징   
    - 프로세스의 물리 메모리를 비연속적으로 할당할 수 있도록 해주는 해주는 운영체제의 메모리 관리 기법.   
    - 페이지(Page): '논리메모리(가상 메모리)'를 동일한 크기로 나눈 블록   
    - 프레임(Frame): '물리 메모리'를 동일한 크기로 나눈 블록   
    - 주로 4kb 혹은, 8kb 단위로 사용   
    - 특징   
      1) 외부 단편화   
        - 고정 크기 단위 할당으로 외부 단편화 발생 x   
        - 효율적인 메모리 공간 활용   

      2) 페이지 테이블(Page Table)   
        - 논리 주소를 물리 주소로 변환하는 맵핑 테이블   
        - 각각의 프로세스마다 독립적인 페이지 테이블 소유 (바로 위의 사유로 인해)   
        - 페이지 번호와 프레임 번호를 매핑   

      3) 주소 변환 과정
        - 페이지 번호로 페이지 테이블을 조회   
        - 해당 프레임 번호 + 오프셋 = 물리주소 로 유추하여 맵핑   
    
    - 장점   
      1) 외부 단편화 해결   
      2) 물리 메모리를 비연속적 할당 가능   
      3) 메모리 보호와 공유가 용이함   

    - 단점   
      1) 내부 단편화 발생 가능 (페이지 내부의 남는 공간에 대해)   
      2) 페이지 테이블을 위한 추가 메모리 필요(어찌보면 메타 데이터이니...)   
      3) 주소 변환 오버해드   
    
    - 요약: 페이징은 현대 운영체제에서 가상 메모리 구현의 기반이되는 기술이다. / 패킷 처럼 조각내어 프로세싱하는 방식(?)   
  
  4) 스와핑   
    - 메모리가 부족할때, 프로세스 전체를 주기억장치(RAM)와 보조기억장치(Drive) 사이에서 이동시키는 메모리 관리 기법.
    - Swap-out: 메모리에서 드라이브로 프로세스를 내보냄 / Swap-in: 드라이브에서 메모리로 프로세스를 불러옴   
    - 다른 프로세스가 실행중 이거나 대기 상태일때, 해당 프로세스를 드라이브의 스왑영역(Swap Space)으로 이동시켜 메모리 공간을 확보   
    - (사용안하는 프로세스를 드라이브에 저장했다가 사용할때만 메모리에 적재하는 방식인듯)   

    - 스와핑 과정
      1) 메모리 부족 감지   
      2) 실핼중이지 않는 프로세스를 선택   
      3) 선택된 프로세스를 통째로 드라이브로 이동 / (Swap - Out)   
      4) 메모리 확보: 비워진 공간에 새 프로세스 적재   
      5) 이후, 필요할 때 디스크에서 다시 메모리로 호출 / (Swap - In)   
    
    - 특징   
      1) 전체 프로세스 단위로의 이동   
        - 프로세스의 모든 데이터를 한꺼번에 이동 / (코드, 데이터, 스택 등)   
        - 페이징의 페이지 단위 이동과는 다름(페이징은 프로세스를 쪼개서 이동하는 방식)   
      
      2) 컨텍스트 스위칭과의 관계   
        - 프로세스 전환 시 마다 스와핑 발생 가능성
        - CPU 스케줄러가 스왑된 프로세스를 선택하면 Swap-In 작업 필요 / CPU 부하량 증가   
      
      3) 스왑 공간(Swap Space)   
        - 디스크의 일부 영역을 스왑 전용으로 할당되어짐   
        - 일반 파일 시스템보다 빠른 접근을 위해 별도로 관리   
        
    - 장점   
      1) 물리 메모리보다 더 많은 프로세스 실행 가능   
      2) 멀티프로그래밍의 정도(degree) 향상   
      3) 메모리 활용도 증대   

    - 단점   
      1) 디스크 i/o가 매우 느림으로 인해 주요 성능 저하 요인으로 지목됨   
      2) 스와핑 오버헤드가 큼   
      3) 프로세스 전체를 이동시킴으로 시간이 오래 걸림   

    - 현대적 변형 / 페이지 스와핑 방식   
      - 전통적인 스와핑 방식보다 페이지 단위 스와핑을 주로 사용   
      1) 프로세스 전체가 아닌 개별 페이지에 대해서만 swap이 이루어짐   
      2) 가상 메모리와 결합하여 더 효율적인 동작   
      3) 페이지 폴트 발생 시, 필요한 페이지만 호출   

    - 요약: 스와핑은 메모리 부족 문제를 해결하는 고전적 기법이지만, 성능 오버헤드가 커서 페이징 방식과 결합한 방식을 현대 시스템에서 사용한다.    

    * 오버헤드(overhead): 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리(자원을 말하는 듯)등을 말한다.   


  5) CPU 스케줄링: 여러 프로그램들이 동시에 CPU를 필요로 할 때, 어느 프로세스 부터 처리할지 부터 얼마나 실행할지에 대한 CPU 리소스 할당에 대한 OS의 관리를 말함.  

  6) 시스템 호출(System Call): 무차별적 자원 접근을 막기위해 OS가 하드웨어와 사용자영역 사이에 위치하여 자원접근에 대한 대리자의 역할을 수행. / (중간자 역할 / JAVA의 Interface의 역할인듯)   

  7) *운영체제는 사용자를 위한 프로그램이 아니다. => 프로그램을 위한 프로그램이다. => 그래서 프로그램을만드는 개발자는 운영체제를 알아야 한다.   
    - ex) 리턴되는 오류에 대해 좀 더 근원적인 분석과 접근이 가능해지면서 문제 해결 능력이 상승한다.   
  
  

# 11월 17일
 1. Wine 설치
 -- Wine is not emulator --
  - wine은 Linux와 같은 Unix 계열 운영체제에서 윈도우즈 프로그램을 실행할 수 있도록 해주는 호환성 계층(compatibility layer)다.
  - 즉, 윈도우에서의 동작을 재구성해서 리눅스에서 직접 실행될 수 있도록 하는 방식.(일종의 컨버팅?)   

  ```bash
    sudo apt update # wine 설치 과정
    sudo apt install wine
  ```   

  - 설치 이후, 별도의 기본적인 설정을 할 수 있다.(winecfg)
  (윈도우즈 환경 설정 + 필요한 라이브러리 드라이버 설치 가능)   


  2. wine을 활용하여 카카오톡 설치   
   1) 우선 윈도우 버전의 카카오톡 설치파일을 다운로드하여 준비한다.(exe 파일...;;)   
   2) 이후, 터미널에 다음 명령어를 입력해주고 실행.   
   ```bash
    LANG="ko_KR.UTF-8" wine kakaoTalk_Setup.exe
   ```   
   3) 이후 과정은 윈도우 설치과정과 동일하다.   
    - 다만, 속도가 좀 느리다...   
  

  3. 타입스크립트로 카페 키오스크 페이지 코드 짜보기
   - 타입을 생성하고 import하여 타입을 준수하여 짜보는거 해보는중...   
   
  
  4. GIMP 설치   
   - 우분투 환경에서는 포토샵 프로그램으로 GIMP 가 그역할을 하고있다.   
   ```bash
    sudo apt update
    sudo apt install gimp
   ```   

   5. Remmina 설치
    - 집에 있는 미니PC 원격연결이 필요할수도 있어서 원격연결 방법을 찾던중 해당 프로그램을 찾게 되었다.
    ``` bash   
      # Remmina 수동 설치하기
      $ sudo snap install remmina
    ```   

    - 이후 어떤 경고문이 뜰텐데, snap 으로 설치할 경우에 대한 보안상의 이유로 명시해준다.   
    - 따라서, 수동으로 제한을 풀어주는작업을 진행했다.   

    ``` bash
      # Remmina permission settings
      $ sudo snap connect remmina:audio-record :audio-record
      $ sudo snap connect remmina:avahi-observe :avahi-observe
      $ sudo snap connect remmina:cups-control :cups-control
      $ sudo snap connect remmina:mount-observe :mount-observe
      $ sudo snap connect remmina:password-manager-service :password-manager-service
    ```   

    - 이후 프로그램 실행 후, 프로토콜값을 RDP로 바꿔준 이후, ip주소와 유저정보를 입력하여 원격연결에 성공했다.   
    



# 11월 14일
 1. 가지고있던 노트북 하나를 다 밀고 우분투를 설치했다...
  - refus 로 부팅용 usb(8기가 이상) 하나 포맷해주고 우분투 iso 파일로 구워서 노트북에 설치
  - 스펙사항:
    - Ubuntu 24.04.3 LTS
    - Acer Aspire E5-576
    - Intel® Core™ i5-8250U × 8
    - memory : 16.0 GiB

  - 설치 및 세팅
    1) Vim
    ``` bash
      $ sudo apt-get update
      $ sudo apt-get install vim
    ```   

    2) Git
    ```bash
      $ sudo apt update
      $ sudo add-apt-repository ppa:git-core/ppa
      $ sudo apt update
      $ sudo install git

      # git이 정상 설치됐는지 확인
      $ git version

      # 유저명과 이메일 주소 설정
      $ git config --global user.name name
      $ git config --global user.email name@email.com

      # 유저명과 이메일 주소 확인
      $ git config user.name
      $ git config user.email
    ```
  
    3) 우분투 vscode에서 한글 입력 안됐던 문제... 
    - https://gist.github.com/philoskim/a79440bd51ae40f04a4d7cafa472caf1
    - 결론: snap(앱센터) 으로 설치하지 말고 전통적인 방식을 고수하자...   

    4) 이외 여럿 설치 항목도 있지만 충분히 구글링 하면서 해결완료   

    <hr/>

 2. 리액트 타입스크립트 학습시작
  - 깃허브 : https://github.com/hooting76/tsx-etc-more   
  - 내용   
    1) 타입스크립트는 input/output 각각 타입을 분명하게 명시해야 한다.   
    2) 이러한 타입중에 객체형태의 타입은 따로 ts파일로 저장해서 사용하며, model 이란 폴더명으로 관리한다.
    3) type 과 interface 의 타입이 각각 존재하며, 차이는 다음과 같다.   


-------------------------------------------------
| 구분 | `interface` | `type` |
|------|-------------|--------|
| **선언 병합** | ✅ 가능 (같은 이름으로 여러 번 선언 시 자동 병합) | ❌ 불가능 (중복 선언 시 에러) |
| **확장 방식** | `extends` 키워드 사용 | `&` (인터섹션) 사용 |
| **Union 타입** | ❌ 불가능 | ✅ 가능 (`string \| number`) |
| **Tuple 타입** | ❌ 불가능 | ✅ 가능 (`[string, number]`) |
| **Primitive 별칭** | ❌ 불가능 | ✅ 가능 (`type ID = string`) |
| **Mapped Types** | ❌ 불가능 | ✅ 가능 |
| **객체 타입 정의** | ✅ 가능 | ✅ 가능 |
| **성능** | 약간 더 빠름 (캐싱 최적화) | 약간 느림 |   
--------------------------------------------------   

## 정리

--------------------------
| 상황 | 추천 |
|------|------|
| **공개 API/라이브러리** | `interface` (사용자가 확장 가능) |
| **React Props/State** | `interface` (명확한 에러 메시지) |
| **일반 객체 타입** | `interface` |
| **Union/Intersection** | `type` |
| **Tuple 타입** | `type` |
| **Utility/Helper 타입** | `type` |
| **복잡한 타입 조합** | `type` |
---------------------------

## 예시 : 확장 (Extension)   
```typescript
// interface
interface Animal {
  name: string;
}
interface Dog extends Animal {
  bark(): void;
}

// type
type Animal = {
  name: string;
}
type Dog = Animal & {
  bark(): void;
}
```
